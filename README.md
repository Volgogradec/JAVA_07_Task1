## Задача №1 - Синдром 100%

### Легенда

Вы попали в команду максималистов, которые хотят, чтобы те авто-тесты, которые вы пишете, покрывали код на 100%.

Но вот незадача:
1. Непонятно, что такое 100%
2. Непонятно, как это сделать

Вспоминаем: покрытием кода у нас занимается JaCoCo, но он просто "сигнализирует" о том, что конкретно пошло не так.

Большинство подобных плагинов помимо целей отчётности (`report`) содержат ещё цель `check`, которая обрушает сборку, если не выполнены определённые проверки.

Что вам нужно:
1. Изучить [документацию на плагин](https://www.eclemma.org/jacoco/trunk/doc/maven.html) (а конкретно на цель `check`)
1. Внедрить эту цель в фазу `verify` (обратите внимание, что эта цель итак публикуется в эту фазу)
1. Настроить правила по покрытию на 100% (при этом нужно изучить разницу между счётчиками `INSTRUCTION`, `LINE`, `BRANCH`, `COMPLEXITY`)
1. Выбрать один из счётчиков и добиться 100% покрытия тестами

По шагам:
1. Скачиваете [проект с лекции](https://github.com/netology-code/javaqa-code/tree/master/2.5_ci)
1. Изучаете документацию, экспериментируете со счётчиками (`INSTRUCTION`, `LINE`, `BRANCH`, `COMPLEXITY`)
1. Выбираете один из счётчиков (на ваше усмотрение из первых трёх: `INSTRUCTION`, `LINE`, `BRANCH`)
1. Запускаете, удостоверяетесь, что сборка падает, делаете push в GitHub (так, чтобы в логах осталось, что сборка падала в CI)
1. Дописываете тесты, чтобы обеспечить 100% по выбранному счётчику, делаете push в GitHub (так, чтобы в логах осталось, что сборка зелёная в CI)

Итого: у вас должен быть репозиторий на GitHub, в котором расположен ваш Java-код + файлик README.md, в котором кратко описано, какой из счётчиков за что отвечает.

<details>
  <summary>Подсказка №1</summary>
  
  Не всегда все плагины хорошо документированы. Достаточно часто плагин просто запускает какой-то инструмент. И именно в документации самого инструмента раскрываются значения параметров.
  
  Также и с JaCoCo. Вы можете найти описание счётчиков и их назначения [на странице документации самого инструмента JaCoCo](https://www.jacoco.org/jacoco/trunk/doc/) (не плагина).
  
</details>

### Instructions (C0 Coverage)
Наименьшая единица, которую считает JaCoCo, - это инструкции по байт-коду Java. Охват инструкций предоставляет информацию о количестве кода, который был выполнен или пропущен. Этот показатель полностью независим от исходного форматирования и всегда доступен даже при отсутствии отладочной информации в файлах классов.

### Branches (C1 Coverage)
JaCoCo также рассчитывает покрытие филиала для всех операторов if и switch. Эта метрика подсчитывает общее количество таких ветвей в методе и определяет количество выполненных или пропущенных ветвей. Покрытие веток всегда доступно, даже в отсутствие отладочной информации в файлах классов. Обратите внимание, что обработка исключений не рассматривается как ветви в контексте этого определения счетчика.

Если файлы классов были скомпилированы с отладочной информацией, точки принятия решения могут быть сопоставлены с исходными строками и выделены соответствующим образом:
1. Нет покрытия: не было выполнено ни одной ветки в строке (красный ромб)
1. Частичное покрытие: была выполнена только часть ветвей в линии (желтый ромб)
1. Полный охват: все ветки в линии были выполнены (зеленый бриллиант)

### Complexity
JaCoCo также вычисляет цикломатическую сложность для каждого неабстрактного метода и суммирует сложность для классов, пакетов и групп. Согласно определению McCabe1996 цикломатическая сложность - это минимальное количество путей, которые в (линейной) комбинации могут генерировать все возможные пути через метод. Таким образом, значение сложности может служить индикатором для количества случаев модульного тестирования, чтобы полностью охватить определенную часть программного обеспечения. Показатели сложности всегда можно рассчитать даже при отсутствии отладочной информации в файлах классов.

### Lines
Для всех файлов классов, которые были скомпилированы с отладочной информацией, можно рассчитать информацию покрытия для отдельных строк. Строка источника считается выполненной, когда выполнена хотя бы одна инструкция, назначенная этой строке.

В связи с тем, что одна строка обычно компилируется в инструкции из нескольких байт-кода, выделение исходного кода показывает три разных состояния для каждой строки, содержащей исходный код:
1. Нет покрытия: не было выполнено ни одной инструкции в строке (красный фон)
1. Частичное покрытие: только часть инструкции в строке была выполнена (желтый фон)
1. Полный охват: все инструкции в строке выполнены (зеленый фон)

В зависимости от форматирования исходного кода одна строка исходного кода может ссылаться на несколько методов или несколько классов. Поэтому счетчик строк методов не может быть просто добавлен, чтобы получить общее число для содержащего класса. То же самое относится и к строкам нескольких классов в одном исходном файле. JaCoCo рассчитывает покрытие строк для классов и исходного файла на основе фактических исходных строк.